package Java基础;

public class 面向对象基础 {
    /*

面向对象思想编程内容的三条主线分别是什么？
    类及类的成员:属性、方法。构造器：代码块、内部类。
    面向对象的三大特征:封装、继承、多态
    其它关键字:this,super,abstract,interface,static,final,package,import

栈、堆、方法区
    栈(Stack），是指虚拟机栈。虚拟机栈时于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型( boolean、byte、char、short、int、float、long、double）和
                对象引用( reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。
    堆(Heap)、此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例，对象的属性，以及数组都要在堆上分配。
    方法区(Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

修饰符
                private default protected public
当前类             √        √        √        √
同一包                      √        √        √
其他包的子类                          √        √
其他包的非子类（同一个工程）                     √
类中应该有属性和方法，属性不应该是static的，因为static修饰的属性所有对象都只有一个值

类中属性的使用
属性（成员变量）和局部变量
1.相同点
    1.1 都有作用域
    1.2 都得先声明，后使用
    1.3 格式都是 变量名 = 变量值;
2.不同点
    2.1，属性（成员变量）直接定义在类的一对{}中
         局部变量定义在方法内，方法形参，代码块内，构造器形参，构造器内部的变量
    2.2 权限修饰符的不同
          属性（成员变量）：可以在声明属性时，指明其权限，常用的权限修饰符：private default（默认的，不写修饰符就默认时default） protected public
          局部变量不可以使用权限修饰符
    2.3 默认初始化值
          属性（成员变量）：类的属性有初始化值，跟数组一样
          局部变量：没有初始化值，调用前要赋值
    2.4 二者在内存中加载的位置不同
          属性加载到堆空间
          局部变量加载到栈中

方法举例与格式: 权限修饰符(四种private default protected public) 返回值类型 方法名(形参)

public void fangfa(String name,int age){}


Java中static、final、abstract、static final的区别
final：
final可以修饰：属性，方法，类，局部变量（方法中的变量）
final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。
final修饰的属性跟具体对象有关，在运行期初始化的final属性，不同对象可以有不同的值。
final修饰的属性表明是一个常数（创建后不能被修改）。
final修饰的方法表示该方法在子类中不能被重写，final修饰的类表示该类不能被继承。
对于基本类型数据，final会将值变为一个常数（创建后不能被修改）；但是对于对象句柄（亦可称作引用或者指针），final会将句柄变为一个常数（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象。但是，对象的本身是可以修改的。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值）。

static：
static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类）
static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。
static修饰的属性所有对象都只有一个值。
static修饰的属性强调它们只有一个。
static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等
static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。
static不可以修饰局部变量。

abstract
abstract修饰类，使这个类成为一个抽象类，类将不能生成对象实例，但可以做为对象变量声明的类型，也就是编译时类型，抽象类就像当于一类的半成品，需要子类继承并覆盖其中的抽象方法。
abstract修饰方法，使这个方法变成抽象方法，即只有声明（定义）而没有实现，实现部分以";"代替。需要子类继承实现（覆盖）。
（1）有抽象方法的类一定是抽象类。但是抽象类中不一定都是抽象方法，也可以全是具体方法。abstract修饰符在修饰类时必须放在类名前。
     abstract修饰方法就是要求其子类覆盖（实现）这个方法。调用时可以以多态方式调用子类覆盖（实现）后的方法，即抽象方法必须在其子类中实现，除非子类本身也是抽象类。
（2）父类是抽象类，其中有抽象方法，那么子类继承父类，并把父类中的所有抽象方法都实现（覆盖）了，子类才有创建对象的实例的能 力，否则子类也必须是抽象类。抽
    象类中可以有构造方法，是子类在构造子类对象时需要调用的父类（抽象类）的构造方法。
（3）不能放在一起的修饰符：final和abstract，private和abstract，static和abstract，因为abstract修饰的方法是必须在其子类中实现（覆盖），才能以多态方式调用，
    以上修饰符在修饰方法时期子类都覆盖不了这个方法，final是不可以覆盖，private是不能够继承到子类，所以也就不能覆盖，static是可以覆盖的，
    但是在调用时会调用编译时类型的方法，因为调用的是父类的方法，而父类的方法又是抽象的方法，又不能够调用，所以上的修饰符不能放在一起。

static final和final static：
static final和final static没什么区别，一般static写在前面。
static final：
static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。
static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用

1、面向对象
　　面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。

2、对象
　　对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。
   类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。
   当不存在对一个对象的引用时，该对象成为一个无用对象。Java的垃圾收集器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。当系统内存用尽或调用System.gc( )要求垃圾回收时，垃圾回收线程与系统同步运行。

3、类 结构：（属性，方法，构造器，代码块，内部类）
类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性和方法两个主要部分。
类声明
[public][abstract|final] class className [extends superclassName] [implements interfaceNameList]{……}
其中，修饰符public,abstract,final 说明了类的属性，className为类名，superclassName为类的父类的名字，interfaceNameList为类所实现的接口列表。

Java中的类实现包括两个部分：类声明和类体。
    class className{
        [public | protected | private ] [static] [final] [transient] [volatile] type variableName;//成员变量
        [public | protected | private ] [static] [final | abstract] [native] [synchronized] returnType methodName([paramList]) [throws exceptionList]{
            statements
    }//成员方法
}
成员变量限定词的含义：
    static: 静态变量（类变量）
    final: 常量；transient: 暂时性变量，用于对象存档，用于对象的串行化
    volatile: 贡献变量，用于并发线程的共享
　　方法的实现也包括两部分内容：方法声明和方法体。

方法声明
　　方法声明中的限定词的含义：
    static: 类方法，可通过类名直接调用
    abstract: 抽象方法，没有方法体
    final: 方法不能被重写
    native: 集成其它语言的代码
    synchronized: 控制多个并发线程的访问
　　方法声明包括方法名、返回类型和外部参数。其中参数的类型可以是简单数据类型，也可以是复合数据类型（又称引用数据类型）。
　　对于简单数据类型来说，java实现的是值传递，方法接收参数的值，但不能改变这些参数的值。如果要改变参数的值，则用引用数据类型，因为引用数据类型传递给方法的是数据在内存中的地址，方法中对数据的操作可以改变数据的值。

方法体
　　方法体是对方法的实现，它包括局部变量的声明以及所有合法的Java指令。方法体中声明的局部变量的作用域在该方法内部。若局部变量与类的成员变量同名，则类的成员变量被隐藏。
　　为了区别参数和类的成员变量，我们必须使用this。this用在一个方法中引用当前对象，它的值是调用该方法的对象。返回值须与返回类型一致，或者完全相同，或是其子类。当返回类型是接口时，返回值必须实现该接口。

构造方法
    构造方法是一个特殊的方法。Java 中的每个类都有构造方法，用来初始化该类的一个对象。
    构造方法具有和类名相同的名称，而且不返回任何数据类型。
    重载经常用于构造方法。
    构造方法只能由new运算符调用

4、面向对象的基本特性（封装，继承，多态）
封装
　　封装性就是尽可能的隐藏对象内部细节，对外形成一道边界，只保留有限的接口和方法与外界进行交互。封装的原则是使对象以外的部分不能随意的访问和操作对象的内部属性，从而避免了外界对对象内部属性的破坏。
　　可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐藏。
    private：类中限定为private的成员，只能被这个类本身访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。
    default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个类本身和同一个包中的类所访问。
    protected：类中限定为protected的成员，可以被这个类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。
    public：类中限定为public的成员，可以被所有的类访问。

继承
    子类的对象拥有父类的全部属性与方法，称作子类对父类的继承。
    Java中父类可以拥有多个子类，但是子类只能继承一个父类，称为单继承。
    继承实现了代码的复用。
    Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。
    子类不能继承父类中访问权限为private的成员变量和方法。
    子类可以重写父类的方法，即命名与父类同名的成员变量。
    Java中通过super来实现对父类成员的访问，super用来引用当前对象的父类。super 的使用有三种情况：
    访问父类被隐藏的成员变量，如：super.variable;
    调用父类中被重写的方法，如：super.Method([paramlist]),super()调用父类构造方法;
    调用父类的构造函数，如：super([paramlist]);

多态
　　对象的多态性是指在父类中定义的属性或方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或方法在父类及其各个子类中具有不同的语义。例如："几何图形"的"绘图"方法，"椭圆"和"多边形"都是"几何图"的子类，其"绘图"方法功能不同。
　　Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）。
    编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据参数的不同来静态确定调用相应的方法。
    运行时多态：由于子类继承了父类所有的属性（私有的除外），所以子类对象可以作为父类对象使用。程序中凡是使用父类对象的地方，都可以用子类对象来代替。一个对象可以通过引用子类的实例来调用子类的方法。

重载（Overloading）
    方法重载是让类以统一的方式处理不同数据类型的手段。
    一个类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法。
    返回值类型可以相同也可以不相同，无法以返回型别作为重载函数的区分标准。

重写（Overriding）
    子类对父类的方法进行重新编写。如果在子类中的方法与其父类有相同的的方法名、返回类型和参数表，我们说该方法被重写 (Overriding)。
    如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
    子类函数的访问修饰权限不能低于父类的。
     */
    public static void main(String[] args) {
        test test1 = new test();
        test1.age = 22;
        test1.printAge();//输出22
        test test2 = new test();
        test2.printAge();//输出18
        test2.printKey();//输出0

        test[] shuzu = new test[5];
        shuzu[0] = new test();
        shuzu[0].printKey();//输出0

        //匿名对象
        new phone();
        //
        new phone().price = 120.3;
        //匿名对象的使用
        PhoneMall phoneMall = new PhoneMall();
        phoneMall.show(new phone());
    }
}
class test{
    //属性
    String name = "zhangshuo";
    int age = 18;
    short key;
    static int legs = 2;
    public void printName(){
        System.out.println(name);
    }
    public void printAge(){
        System.out.println(age);
    }
    public void printKey(){
        System.out.println(key);
    }
}
//匿名对象
class PhoneMall{
    public void show(phone phone){
        phone.sendEmail();
    }
}
class phone{
    double price;
    public void sendEmail(){
        System.out.println("sendEmail");
    }
}
