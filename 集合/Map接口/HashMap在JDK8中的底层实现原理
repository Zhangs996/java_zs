HashMap的内部存储结构其实是数组+链表+红黑树的结合。当实例化一个HashMap时，
会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，
这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，
每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素

每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，
用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，
每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。
而新添加的元素作为链表的last，或树的叶子结点。

那么HashMap什么时候进行扩容和树形化呢？
当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor时，
就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。
也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，
那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，
就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，
所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。

当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，
如果已经达到了64，那么这个链会变成红黑树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，
下次resize方法时判断树的结点个数低于6个，也会把红黑树再转为链表。

关于映射关系的key是否可以修改？answer：不要修改
映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，
因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。
